typeIC<-3
set.seed(1111)
t.stop<-40
long.inter.mat2<-NULL
long.inter.mat1<-NULL
for (we in 1:1){
n<-network.size(HH.network)
hh.id<- HH.network %v% "hh_id"
hh.size<- HH.network %v% "hh_size"
status.matrix.1<- data.frame(infected          = rep(0,n),  # 1
time.of.infection  = NA,        # 2
infector           = NA,        # 3
severity           = 0,         # 4 1 Symptomatic 2 Asymptomatic
TimeSymptomOnset   = Inf,       # 5
Immunity           = 0,         # 0 no immunity, 1 vaccinated
Recovery           = Inf)
status.matrix.2 <-status.matrix.1
recovery.vector.1<-rep(Inf,n) #vector giving the recovery times
recovery.vector.2<-rep(Inf,n) #vector giving the recovery times
events<-data.frame("NextCtc"=Inf, "HomeQuarantine"=Inf, "Recovery"=Inf, "NewPathogen"=Inf, "NewSeeding1"=Inf, "NewSeeding2"=Inf )
events$NewPathogen<-t2
events$NewSeeding1<-t.seed
events$NewSeeding2<-t2+t.seed
infectives<-rep(0,n) # vector that indicates who is infectious at the current time: 1 infectious 0 non infectious
current.time<-0
index.contact.within<-rep(0,n) # vector that selects the individuals that have to propose a new social contact(global) - 1 yes 0 no
index.contact.between<-rep(0,n) # vector that selects the individuals that have to propose a new social contact(global) - 1 yes 0 no
time.events<-matrix(NA,1,3)
#transmission parameter dataframe: each line is an individual, the first colum is the transmsission coeffficient and the third the length of IP (needed to re-scale Viral load curve)
transmission.parameters<-data.frame("id"=1:n,"q1h"=rep(NA,n),"q1g"=rep(NA,n),"q2h"=rep(NA,n),"q2g"=rep(NA,n), "contact_rate_within"=rep(NA,n),"contact_rate_between"=lambda.g, "susceptibility"=rep(1,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
for (j in 1:n){
transmission.parameters$contact_rate_within[j]<-length(get.neighborhood(HH.network,j))
}
#Proportion of immune
if (prop.immune>0){
if (pathogen.1=="DELTA" & pathogen.2=="OMICRON"){
immuned.individuals<-sample(1:n,round(prop.immune*n))
status.matrix.1$Immunity[immuned.individuals]<-1
status.matrix.2$Immunity<-status.matrix.1$Immunity
}else{
immuned.individuals<-sample(1:n,round(prop.immune*n))
status.matrix.1$Immunity[immuned.individuals]<-1
immuned.individuals<-sample(1:n,round(prop.immune*n))
status.matrix.2$Immunity[immuned.individuals]<-1
}
}
homequarantine.day.1<-rep(Inf,n)
homequarantine.day.2<-rep(Inf,n)
homequarantine<-rep(0,n)
stop.quarantine<-rep(Inf,n)
contact.time.within<-data.frame("id"=1:n,"pr.ctc"=rep(NA,n),"pr.infectee"=rep(NA,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
contact.time.between<-data.frame("id"=1:n,"pr.ctc"=rep(NA,n),"pr.infectee"=rep(NA,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
# first infected: randomly chosen in the population (among the susceptibles)
potential.seeds<-which(hh.size==2)
first.cases<-sample(potential.seeds[which(status.matrix.1[potential.seeds,1]==0)],nSeeds.1)
for (j in first.cases){
first<-j
status.matrix.1$infected[first] <- 1
status.matrix.1$time.of.infection[first] <- 0
status.matrix.1$Recovery[first]<-current.time+infectious.period.length(pathogen = pathogen.1)
# if (runif(1)<rho.1){ #if symptomatic #index cases are always symptomatic individuals
transmission.parameters$q1h[first]<-inf.path.1.h #A single q parameter for everyone
transmission.parameters$q1g[first]<-inf.path.1.g #A single q parameter for everyone
status.matrix.1$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.1)
if(runif(1)<bc.1){
homequarantine.day.1[first]<-status.matrix.1$TimeSymptomOnset[first]
}
status.matrix.1$severity[first]<-1
time.events<-rbind(time.events,c(current.time,1.1,first))
#}
#else{
#  transmission.parameters$q1h[first]<-inf.path.1.h*alpha.as.1 #A single q parameter for everyone
#  transmission.parameters$q1g[first]<-inf.path.1.g*alpha.as.1 #A single q parameter for everyone
#  status.matrix.1$severity[first]<-2
#  time.events<-rbind(time.events,c(current.time,1.2,first))
#}
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
proposed.individual<-0
temp.contact.time<-0
indiv.prop.ctc<-0
recovered<-0
err<-0
Rt1<-matrix(data = NA, nrow = 1, ncol = 2)
Rt2<-matrix(data = NA, nrow = 1, ncol = 2)
#When only the first pathogen is present
while((sum(infectives)>0 & current.time<t.stop) | current.time<t2){ #while there are still infectives
#Phase 1: individuals that has to, propose a new social contac
for (i in which(index.contact.within==1) ){ # for all the individuals that has to propose a global contact
contact.time.within$pr.ctc[i]<-ifelse(transmission.parameters$contact_rate_within[i]!=0,rexp(1,transmission.parameters$contact_rate_within[i])+current.time,Inf)# I generate the next interarrival time for individual i
index.contact.within[i]<-0
}
for (i in which(index.contact.between==1) ){ # for all the individuals that has to propose a global contact
contact.time.between$pr.ctc[i]<-rexp(1,transmission.parameters$contact_rate_between[i])+current.time# I generate the next interarrival time for individual i
index.contact.between[i]<-0
}
contact.time.overall<-c(contact.time.within$pr.ctc, contact.time.between$pr.ctc) #overall contact times
recovery.vector.overall<-c(status.matrix.1$Recovery ,status.matrix.2$Recovery)
homequarantine.day.overall<-c(homequarantine.day.1,homequarantine.day.2)
#Phase 2: identify the next event: possible infection, recovery or the start of the new pathogen infection
ifelse(length(which(is.na(contact.time.overall)==FALSE))>0,events$NextCtc<-min(contact.time.overall, na.rm = T),events$NextCtc<-Inf) # among all the proposed social contact between houeholds we select the minimum
ifelse(length(which(!is.infinite(homequarantine.day.overall)))>0,events$HomeQuarantine<-min(homequarantine.day.overall),events$HomeQuarantine<-Inf ) #minimum quarantine pathogen 1
ifelse(length(which(is.na(recovery.vector.overall)==FALSE))>0,events$Recovery<-min(recovery.vector.overall, na.rm = T),events$Recovery<-Inf) # among all the proposed social contact between houeholds we select the minimum
next.evts<-colnames(events)[which(min(events)==events)]
if (length(next.evts)>1){
next.evts<-sample(colnames(events)[which(min(events)==events)],1)
}
if (next.evts=="NextCtc"){
current.time<-events$NextCtc
if (length(min(contact.time.overall, na.rm = T))>1){ #when two contacts happen at the same time
selected.ctc<-sample(which(contact.time.overall==current.time),1)
if (selected.ctc!=n & selected.ctc!=2*n){
infector<- selected.ctc %% n
}else{
infector<- n
}
if (selected.ctc<=n){
infectee.pool<-get.neighborhood(HH.network,infector)
if (length(infectee.pool)>1){
infectee<-sample(infectee.pool,1) #pick a random individual in the class
}
if(length(infectee.pool)==1){
infectee<-infectee.pool #pick a random individual in the class
}
if(length(infectee.pool)==0){
infectee<-infector #just a trick to have acceptance rate 0 (infector is not susceptible)
}
index.contact.within[infector]<-1
contact.time.within$pr.ctc[infector]<-NA
ctc<-"hh"
}else{
infector<-which(contact.time.between$pr.ctc == events$NextCtc)
hh.members.temp<-which(hh.id==hh.id[infector])
infectee.pool<- setdiff(1:n,hh.members.temp) #individuals not in the same class
infectee<-sample(infectee.pool,1) #pick a random individual not in the class (and not a teacher)
index.contact.between[infector]<-1
contact.time.between$pr.ctc[infector]<-NA
ctc<-"g"
}
}else{
if (length(which(events$NextCtc==contact.time.within$pr.ctc))>0){ #if it is a within contact
infector<-which(contact.time.within$pr.ctc ==events$NextCtc)
infectee.pool<-get.neighborhood(HH.network,infector)
if (length(infectee.pool)>1){
infectee<-sample(infectee.pool,1) #pick a random individual in the class
}
if(length(infectee.pool)==1){
infectee<-infectee.pool #pick a random individual in the class
}
if(length(infectee.pool)==0){
infectee<-infector #just a trick to have acceptance rate 0 (infector is not susceptible)
}
index.contact.within[infector]<-1
contact.time.within$pr.ctc[infector]<-NA
ctc<-"hh"
}else{
infector<-which(contact.time.between$pr.ctc == events$NextCtc)
hh.members.temp<-which(hh.id==hh.id[infector])
infectee.pool<- setdiff(1:n,hh.members.temp) #individuals not in the same class
infectee<-sample(infectee.pool,1) #pick a random individual not in the class (and not a teacher)
index.contact.between[infector]<-1
contact.time.between$pr.ctc[infector]<-NA
ctc<-"g"
}
}
#Infection with pathogen 1
#      if (status.matrix.1$infected[infector]==1 & (status.matrix.1$infected[infectee]==0 | (status.matrix.1$infected[infectee]==-1 & reinf==1))){
if (status.matrix.1$infected[infector]==1 & status.matrix.1$infected[infectee]==0){
# compute short interaction terms for pathogen.1 (having pathogen 2)
if (status.matrix.2$infected[infectee]==1){
short.inter<-sigma12
}else{
short.inter<-1
}
#long.inter<-LLImmlev(pathogen.v1 = pathogen.1, pathogen.v2 = pathogen.2, status.matrix.v1 = status.matrix.1, status.matrix.v2 =status.matrix.2, infectee = infectee,lli = lli.2, current.time = current.time, reinf = reinf, typeIC = typeIC, het.vac = het.vac)
long.inter<-LLImmlev.basic(status.matrix.v2 = status.matrix.2,infectee = infectee, lli = lli.2, current.time = current.time,typeIC = typeIC, t.imm.lim = t.imm.lim, pathogen1 = pathogen.1, pathogen2=pathogen.2 )
long.inter.mat1<-c(long.inter.mat1,long.inter)
# compute long interaction terms for pathogen.1 (recovered from pathogen 2 and/or already contracted pathogen 1)
# if (status.matrix.2$infected[infectee]==-1 & short.inter==1){
# long.inter<-long.inter.term.2(t=current.time,status.matrix = status.matrix.2,infectee = infectee)
#    long.inter<-LLImmlev(pathogen.v1 = pathogen.1, pathogen.v2 = pathogen.2, status.matrix.v1 = status.matrix.1, status.matrix.v2 =status.matrix.2, infectee = infectee,lli = lli.2, current.time = current.time, reinf = reinf, typeIC = typeIC)
#  }else{
#    long.inter<-1
#  }
#re-infection term
#re.inf<-Immlev.1(t=current.time,status.matrix = status.matrix.1,infectee = infectee,pathogen = pathogen.1)
ifelse(ctc=="g",q<-transmission.parameters$q1g[infector],q<-transmission.parameters$q1h[infector])
acc.rate.1<-InfMeasure(t= current.time- status.matrix.1$time.of.infection[infector] ,pathogen = pathogen.1)*short.inter*long.inter*q
if ((ctc=="g" & homequarantine[infectee]==1) | status.matrix.1$infected[infectee]==1){acc.rate.1<-0}
if (acc.rate.1>1){err<-err+1}
if (runif(1)<acc.rate.1){
status.matrix.1$infected[infectee] <- 1
status.matrix.1$time.of.infection[infectee] <- current.time
status.matrix.1$infector[infectee] <- infector
status.matrix.1$Recovery[infectee]<-current.time+infectious.period.length(pathogen=pathogen.1)
if (runif(1)<rho.1){ #if symptomatic
transmission.parameters$q1h[infectee]<-inf.path.1.h #A single q parameter for everyone
transmission.parameters$q1g[infectee]<-inf.path.1.g #A single q parameter for everyone
status.matrix.1$TimeSymptomOnset[infectee]<-current.time+incubation.period(pathogen=pathogen.1)
if (runif(1)<bc.1){
homequarantine.day.1[infectee]<-status.matrix.1$TimeSymptomOnset[infectee]
}
status.matrix.1$severity[infectee]<-1
time.events<-rbind(time.events,c(current.time,1.1,infectee))
}else{
transmission.parameters$q1g[infectee]<-inf.path.1.g*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q1h[infectee]<-inf.path.1.h*alpha.as.1 #A single q parameter for everyone
status.matrix.1$severity[infectee]<-2
time.events<-rbind(time.events,c(current.time,1.2,infectee))
}
if (infectives[infectee]==0){
infectives[infectee]<-1
contact.time.within$pr.ctc[infectee]<-ifelse(transmission.parameters$contact_rate_within[infectee]!=0,rexp(1,transmission.parameters$contact_rate_within[infectee])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[infectee]==0){
contact.time.between$pr.ctc[infectee]<-rexp(1,transmission.parameters$contact_rate_between[infectee])+current.time # I generate the next interarrival time for individual i
}
}
}
}
#Infection with pathogen 2
#if (status.matrix.2$infected[infector]==1 & (status.matrix.2$infected[infectee]==0 | (status.matrix.2$infected[infectee]==-1 & reinf==1))){
if (status.matrix.2$infected[infector]==1 & status.matrix.2$infected[infectee]==0){
if (status.matrix.1$infected[infectee]==1){
short.inter<-sigma21
}else{
short.inter<-1
}
# if (status.matrix.1$infected[infectee]==-1 & short.inter==1){
#long.inter<-LLImmlev(pathogen.v1 = pathogen.2, pathogen.v2 = pathogen.1, status.matrix.v1 = status.matrix.2, status.matrix.v2 =status.matrix.1, infectee = infectee,lli=lli.1,current.time = current.time, reinf = reinf, typeIC = typeIC, het.vac = het.vac)
long.inter<-LLImmlev.basic(status.matrix.v2 = status.matrix.1,infectee = infectee, lli = lli.1, current.time = current.time,typeIC = typeIC, t.imm.lim = t.imm.lim, pathogen1 = pathogen.2, pathogen2=pathogen.1)
long.inter.mat2<-c(long.inter.mat2, long.inter)
#  }else{
#    long.inter<-1
#  }
#re-infection term
#re.inf<-Immlev.2(t=current.time,status.matrix = status.matrix.2,infectee = infectee,pathogen = pathogen.2)
ifelse(ctc=="g",q<-transmission.parameters$q2g[infector],q<-transmission.parameters$q2h[infector])
acc.rate.2<-InfMeasure(t=(current.time-status.matrix.2$time.of.infection[infector]),pathogen = pathogen.2)*short.inter*long.inter*q
if ((ctc=="g" & homequarantine[infectee]==1)){acc.rate.2<-0}
if (acc.rate.2>1){err<-err+1}
if (runif(1)<acc.rate.2){
status.matrix.2$infected[infectee] <- 1
status.matrix.2$time.of.infection[infectee] <- current.time
status.matrix.2$infector[infectee] <- infector
status.matrix.2$Recovery[infectee]<-current.time+infectious.period.length(pathogen=pathogen.2)
if (runif(1)<rho.2){ #if symptomatic
transmission.parameters$q2h[infectee]<-inf.path.2.h #A single q parameter for everyone
transmission.parameters$q2g[infectee]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$TimeSymptomOnset[infectee]<-current.time+incubation.period(pathogen=pathogen.2)
if (runif(1)<bc.2){
homequarantine.day.2[infectee]<-status.matrix.2$TimeSymptomOnset[infectee]
}
status.matrix.2$severity[infectee]<-1
time.events<-rbind(time.events,c(current.time,2.1,infectee))
}else{
transmission.parameters$q2g[infectee]<-inf.path.2.g*alpha.as.2 #A single q parameter for everyone
transmission.parameters$q2h[infectee]<-inf.path.2.h*alpha.as.2 #A single q parameter for everyone
status.matrix.2$severity[infectee]<-2
time.events<-rbind(time.events,c(current.time,2.2,infectee))
}
if (infectives[infectee]==0){
infectives[infectee]<-1
contact.time.within$pr.ctc[infectee]<-ifelse(transmission.parameters$contact_rate_within[infectee]!=0,rexp(1,transmission.parameters$contact_rate_within[infectee])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[infectee]==0){
contact.time.between$pr.ctc[infectee]<-rexp(1,transmission.parameters$contact_rate_between[infectee])+current.time # I generate the next interarrival time for individual i
}
}
}
}
# compute the long and short interaction terms for pathogen.2
}
if (next.evts=="HomeQuarantine"){
current.time<-events$HomeQuarantine
quarantined.individuals<-which(homequarantine.day.overall==current.time)
for (k in quarantined.individuals){
if (k != n & k!= 2*n) {
temp.ind<- k %% n
}else{
if (k==n){
homequarantine.day.1[n]<-Inf
stop.quarantine[n]<-status.matrix.1$Recovery[n]
}else{
homequarantine.day.2[n]<-Inf
stop.quarantine[n]<-status.matrix.2$Recovery[n]
}
temp.ind<-n
}
if (k>n){
homequarantine.day.2[temp.ind]<-Inf
stop.quarantine[temp.ind]<-status.matrix.2$Recovery[temp.ind]
}
if (k<n){
homequarantine.day.1[temp.ind]<-Inf
stop.quarantine[temp.ind]<-status.matrix.1$Recovery[temp.ind]
}
if (homequarantine[temp.ind]==1){ #individual is already in quarantine for the other disease
stop.quarantine[temp.ind]<-max(status.matrix.2$Recovery[temp.ind],status.matrix.1$Recovery[temp.ind])
}
homequarantine[temp.ind]<-1
contact.time.between$pr.ctc[temp.ind]<-NA
contact.time.within$pr.ctc[temp.ind]<-NA
index.contact.between[temp.ind]<-0
index.contact.within[temp.ind]<-1
transmission.parameters$contact_rate_within[temp.ind]<-transmission.parameters$contact_rate_within[temp.ind]*contact.reduction
}
}
if (next.evts=="Recovery"){
current.time<-events$Recovery
temp.recovered<-which(recovery.vector.overall==events$Recovery)
for (recovered in temp.recovered){
if (recovered!= n & recovered!=n*2){
if (recovered > n){
recovered<- recovered %% n
Rt2<-comp.RT(status.matrix = status.matrix.2,individual = recovered,Rt=Rt2)
status.matrix.2$infected[recovered]<--1
status.matrix.2$Recovery[recovered]<-Inf
transmission.parameters$contact_rate_within[recovered]<-length(get.neighborhood(HH.network,recovered))
time.events<-rbind(time.events,c(current.time,-2,recovered))
if (status.matrix.1$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}else{
Rt1<-comp.RT(status.matrix = status.matrix.1,individual = recovered,Rt=Rt1)
status.matrix.1$infected[recovered]<--1
status.matrix.1$Recovery[recovered]<-Inf
transmission.parameters$contact_rate_within[recovered]<-length(get.neighborhood(HH.network,recovered))
time.events<-rbind(time.events,c(current.time,-1,recovered))
if (status.matrix.2$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}
}else{
if (recovered == 2*n){
recovered<- n
Rt2<-comp.RT(status.matrix = status.matrix.2,individual = recovered,Rt=Rt2)
status.matrix.2$infected[recovered]<--1
status.matrix.2$Recovery[recovered]<-Inf
transmission.parameters$contact_rate_within[recovered]<-length(get.neighborhood(HH.network,recovered))
time.events<-rbind(time.events,c(current.time,-2,recovered))
if (status.matrix.1$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}else{
Rt1<-comp.RT(status.matrix = status.matrix.1,individual = recovered,Rt=Rt1)
status.matrix.1$infected[recovered]<--1
status.matrix.1$Recovery[recovered]<-Inf
transmission.parameters$contact_rate_within[recovered]<-length(get.neighborhood(HH.network,recovered))
time.events<-rbind(time.events,c(current.time,-1,recovered))
if (status.matrix.2$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}
}
if (stop.quarantine[recovered]==current.time){
homequarantine[recovered]<-0
stop.quarantine[recovered]<-Inf
}
}
}
if (next.evts=="NewPathogen"){
current.time<-events$NewPathogen
events$NewPathogen<-Inf
first.cases<-sample(1:n,nSeeds.2)
for (j in first.cases){
first<-j
status.matrix.2$infected[first] <- 1
status.matrix.2$time.of.infection[first] <- current.time
status.matrix.2$Recovery[first]<-current.time+infectious.period.length(pathogen=pathogen.2)
if (runif(1)<rho.2){ #if symptomatic
transmission.parameters$q2h[first]<-inf.path.2.h #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$severity[first]<-1
status.matrix.2$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.2)
if (runif(1)<bc.2){
homequarantine.day.2[first]<-status.matrix.2$TimeSymptomOnset[first]
}
time.events<-rbind(time.events,c(current.time,2.1,first))
}else{
transmission.parameters$q2h[first]<-inf.path.2.h*alpha.as.2 #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g*alpha.as.2 #A single q parameter for everyone
status.matrix.2$severity[first]<-2
time.events<-rbind(time.events,c(current.time,2.2,first))
}
if (infectives[first]==0){
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[first]==0){
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
}
}
}
if (next.evts=="NewSeeding1"){
current.time<-events$NewSeeding1
events$NewSeeding1<-current.time+t.seed
not.infected<-which(status.matrix.1$infected!=1)
if (nSeeds.1<length(not.infected)){
first.cases<-sample(not.infected,nSeeds.1)
for (j in first.cases){
first<-j
status.matrix.1$infected[first] <- 1
status.matrix.1$time.of.infection[first] <- current.time
status.matrix.1$Recovery[first]<-current.time+infectious.period.length(pathogen=pathogen.1)
if (runif(1)<rho.1){ #if symptomatic
transmission.parameters$q1h[first]<-inf.path.1.h #A single q parameter for everyone
transmission.parameters$q1g[first]<-inf.path.1.g #A single q parameter for everyone
status.matrix.1$severity[first]<-1
status.matrix.1$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.2)
if (runif(1)<bc.1){
homequarantine.day.1[first]<-status.matrix.1$TimeSymptomOnset[first]
}
time.events<-rbind(time.events,c(current.time,1.1,first))
}else{
transmission.parameters$q1h[first]<-inf.path.1.h*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q1g[first]<-inf.path.1.g*alpha.as.1 #A single q parameter for everyone
status.matrix.1$severity[first]<-2
time.events<-rbind(time.events,c(current.time,1.2,first))
}
if (infectives[first]==0){
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[first]==0){
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
}
}
}
}
if (next.evts=="NewSeeding2"){
current.time<-events$NewSeeding1
events$NewSeeding2<-current.time+t.seed
not.infected<-which(status.matrix.2$infected!=1)
if (nSeeds.2<length(not.infected)){
first.cases<-sample(not.infected,nSeeds.2)
for (j in first.cases){
first<-j
status.matrix.2$infected[first] <- 1
status.matrix.2$time.of.infection[first] <- current.time
status.matrix.2$Recovery[first]<-current.time+infectious.period.length(pathogen=pathogen.2)
if (runif(1)<rho.2){ #if symptomatic
transmission.parameters$q2h[first]<-inf.path.2.h #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$severity[first]<-1
status.matrix.2$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.2)
if (runif(1)<bc.2){
homequarantine.day.2[first]<-status.matrix.2$TimeSymptomOnset[first]
}
time.events<-rbind(time.events,c(current.time,2.1,first))
}else{
transmission.parameters$q2h[first]<-inf.path.2.h*alpha.as.2 #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g*alpha.as.2 #A single q parameter for everyone
status.matrix.2$severity[first]<-2
time.events<-rbind(time.events,c(current.time,2.2,first))
}
if (infectives[first]==0){
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[first]==0){
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
}
}
}
}
}
}
long.inter.mat1.T3<-long.inter.mat1
long.inter.mat2.T3<-long.inter.mat2
plot(unique(long.inter.mat1.T1))
plot(unique(long.inter.mat2.T1))
plot(unique(long.inter.mat1.T2))
plot(unique(long.inter.mat1.T3))
225/35
#===========================
#Kwaliteitstechnieken HC 2
#===========================
library(lme4)
library(lmerTest)
