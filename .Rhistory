transmission.parameters$q2g[first]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$severity[first]<-1
status.matrix.2$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.2)
homequarantine.day.2[first]<-status.matrix.2$TimeSymptomOnset[first]
time.events<-rbind(time.events,c(current.time,2.1,first))
}else{
transmission.parameters$q2h[first]<-inf.path.2.h*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g*alpha.as.1 #A single q parameter for everyone
status.matrix.2$severity[first]<-2
time.events<-rbind(time.events,c(current.time,2.2,first))
}
if (infectives[first]==0){
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[first]==0){
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
}
}
}
}
status.matrix.2
time.events[1:20,]
status.matrix.2[57,]
status.matrix.2[27,]
status.matrix.2[65,]
status.matrix.1
time.events
time.events[]1:10,
time.events[1:10,]
status.matrix.1[39,]
status.matrix.1[10,]
status.matrix.1[14,]
status.matrix.1[23,]
status.matrix.1[2,]
status.matrix.1[24,]
status.matrix.1[77,]
status.matrix.1[58,]
status.matrix.1[1,]
time.events[1:10,]
time.events[1:11,]
status.matrix.1[87,]
re.inf.1<-function(t,status.matrix,infectee){
time.since.inf<-t-status.matrix$time.of.infection[infectee]
#(Table 3 booster dose, Delta :BNT162b2 - Andrews et al. NEJM 2022)
if (status.matrix$Immunity[infectee]==1){
if (time.since.inf<14){
value<-0
}
if (time.since.inf>=14 & time.since.inf <28){
value<-(1-0.951)
}
if (time.since.inf>=28 & time.since.inf <63){
value<-(1-0.918)
}
if (time.since.inf>=63){
value<-(1-0.899)
}
}
#(Table 3 2 doses, Delta :BNT162b2 - Andrews et al. NEJM 2022)
if (status.matrix$Immunity[infectee]==0){
if (time.since.inf<14){
value<-0
}
if (time.since.inf>=14 & time.since.inf <28){
value<-(1-0.909)
}
if (time.since.inf>=28 & time.since.inf <63){
value<-(1-0.855)
}
if (time.since.inf>=63 & time.since.inf <98){
value<-(1-0.787)
}
if (time.since.inf>=98 & time.since.inf <133){
value<-(1-0.744)
}
if (time.since.inf>=133 & time.since.inf <168){
value<-(1-0.674)
}
if (time.since.inf>=168){
value<-(1-0.627)
}
}
return(value)
}
re.inf.2<-function(t,status.matrix,infectee){
#Assumption: booster+ Omicron infection creates the same immunity as booster + delta infection (Table 3 booster dose, Delta :BNT162b2 - Andrews et al. NEJM 2022)
value<-0
if (status.matrix$infecte[infectee]!=1){
time.since.inf<-t-status.matrix$time.of.infection[infectee]
if (status.matrix$Immunity[infectee]==1){
if (time.since.inf<14){
value<-(1-0.923)
}
if (time.since.inf>=14 & time.since.inf <28){
value<-(1-0.951)
}
if (time.since.inf>=28 & time.since.inf <63){
value<-(1-0.918)
}
if (time.since.inf>=63){
value<-(1-0.899)
}
}
#(Table 3 2 doses, Delta :BNT162b2 - Andrews et al. NEJM 2022)
if (status.matrix$Immunity[infectee]==0){
if (time.since.inf<14){
value<-0
}
if (time.since.inf>=14 & time.since.inf <28){
value<-(1-0.909)
}
if (time.since.inf>=28 & time.since.inf <63){
value<-(1-0.855)
}
if (time.since.inf>=63 & time.since.inf <98){
value<-(1-0.787)
}
if (time.since.inf>=98 & time.since.inf <133){
value<-(1-0.744)
}
if (time.since.inf>=133 & time.since.inf <168){
value<-(1-0.674)
}
if (time.since.inf>=168){
value<-(1-0.627)
}
}
}
return(value)
}
n<-network.size(HH.network)
hh.id<- HH.network %v% "hh_id"
status.matrix.1<- data.frame(infected          = rep(0,n), # 1
time.of.infection = NA,        # 2
infector          = NA,        # 3
severity          = 0,         # 4 1 Symptomatic 2 Asymptomatic
TimeSymptomOnset  = Inf,       # 5
Immunity          = 0,         # 0 no immunity, 1 vaccinated
Recovery          = Inf)
status.matrix.2 <-status.matrix.1
recovery.vector.1<-rep(Inf,n) #vector giving the recovery times
recovery.vector.2<-rep(Inf,n) #vector giving the recovery times
events<-data.frame("NextCtc"=Inf, "HomeQuarantine"=Inf, "Recovery"=Inf, "NewPathogen"=Inf)
events$NewPathogen<-t2
infectives<-rep(0,n) # vector that indicates who is infectious at the current time: 1 infectious 0 non infectious
current.time<-0
index.contact.within<-rep(0,n) # vector that selects the individuals that have to propose a new social contact(global) - 1 yes 0 no
index.contact.between<-rep(0,n) # vector that selects the individuals that have to propose a new social contact(global) - 1 yes 0 no
time.events<-matrix(NA,1,3)
#transmission parameter dataframe: each line is an individual, the first colum is the transmsission coeffficient and the third the length of IP (needed to re-scale Viral load curve)
transmission.parameters<-data.frame("id"=1:n,"q1h"=rep(NA,n),"q1g"=rep(NA,n),"q2h"=rep(NA,n),"q2g"=rep(NA,n), "contact_rate_within"=rep(NA,n),"contact_rate_between"=lambda.g, "susceptibility"=rep(1,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
for (j in 1:n){
transmission.parameters$contact_rate_within[j]<-length(get.neighborhood(HH.network,j))
}
#Proportion of immune
if (prop.immune>0){
status.matrix.1$Immunity[sample(1:n,round(prop.immune*n))]<-1
status.matrix.2$Immunity<-status.matrix.1$Immunity
}
homequarantine.day.1<-rep(Inf,n)
homequarantine.day.2<-rep(Inf,n)
homequarantine<-rep(0,n)
stop.quarantine<-rep(Inf,n)
contact.time.within<-data.frame("id"=1:n,"pr.ctc"=rep(NA,n),"pr.infectee"=rep(NA,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
contact.time.between<-data.frame("id"=1:n,"pr.ctc"=rep(NA,n),"pr.infectee"=rep(NA,n))   #matrix containing the proposed time of the next contact (first colum) and the contact individual (second column)
# first infected: randomly chosen in the population (among the susceptibles)
first.cases<-sample(which(status.matrix.1[,1]==0),nSeeds.1)
for (j in first.cases){
first<-j
status.matrix.1$infected[first] <- 1
status.matrix.1$time.of.infection[first] <- 0
status.matrix.1$Recovery[first]<-current.time+infectious.period.length(pathogen = pathogen.1)
if (runif(1)<rho.1){ #if symptomatic
transmission.parameters$q1h[first]<-inf.path.1.h #A single q parameter for everyone
transmission.parameters$q1g[first]<-inf.path.1.g #A single q parameter for everyone
status.matrix.1$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.1)
homequarantine.day.1[first]<-status.matrix.1$TimeSymptomOnset[first]
status.matrix.1$severity[first]<-1
time.events<-rbind(time.events,c(current.time,1.1,first))
}else{
transmission.parameters$q1h[first]<-inf.path.1.h*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q1g[first]<-inf.path.1.g*alpha.as.1 #A single q parameter for everyone
status.matrix.1$severity[first]<-2
time.events<-rbind(time.events,c(current.time,1.2,first))
}
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time+status.matrix.1[first,5],Inf)       # I generate the next interarrival time for individual i
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time+status.matrix.1[first,5] # I generate the next interarrival time for individual i
}
proposed.individual<-0
temp.contact.time<-0
indiv.prop.ctc<-0
recovered<-0
err<-0
#When only the first pathogen is present
while((sum(infectives))>0 | current.time<t2){ #while there are still infectives
#Phase 1: individuals that has to, propose a new social contac
for (i in which(index.contact.within==1) ){ # for all the individuals that has to propose a global contact
contact.time.within$pr.ctc[i]<-rexp(1,transmission.parameters$contact_rate_within[i])+current.time# I generate the next interarrival time for individual i
index.contact.within[i]<-0
}
for (i in which(index.contact.between==1) ){ # for all the individuals that has to propose a global contact
contact.time.between$pr.ctc[i]<-rexp(1,transmission.parameters$contact_rate_between[i])+current.time# I generate the next interarrival time for individual i
index.contact.between[i]<-0
}
contact.time.overall<-c(contact.time.within$pr.ctc, contact.time.between$pr.ctc) #overall contact times
recovery.vector.overall<-c(status.matrix.1$Recovery ,status.matrix.2$Recovery)
homequarantine.day.overall<-c(homequarantine.day.1,homequarantine.day.2)
#Phase 2: identify the next event: possible infection, recovery or the start of the new pathogen infection
ifelse(length(which(is.na(contact.time.overall)==FALSE))>0,events$NextCtc<-min(contact.time.overall, na.rm = T),events$NextCtc<-Inf) # among all the proposed social contact between houeholds we select the minimum
ifelse(length(which(!is.infinite(homequarantine.day.overall)))>0,events$HomeQuarantine<-min(homequarantine.day.overall),events$HomeQuarantine<-Inf ) #minimum quarantine pathogen 1
ifelse(length(which(is.na(recovery.vector.overall)==FALSE))>0,events$Recovery<-min(recovery.vector.overall, na.rm = T),events$Recovery<-Inf) # among all the proposed social contact between houeholds we select the minimum
next.evts<-colnames(events)[which(min(events)==events)]
if (length(next.evts)>1){
next.evts<-sample(colnames(events)[which(min(events)==events)],1)
}
if (next.evts=="NextCtc"){
current.time<-events$NextCtc
if (length(min(contact.time.overall, na.rm = T))>1){ #when two contacts happen at the same time
selected.ctc<-sample(which(contact.time.overall==current.time),1)
if (selected.ctc!=n & selected.ctc!=2*n){
infector<- selected.ctc %% n
}else{
infector<- n
}
if (selected.ctc<=n){
infectee.pool<-get.neighborhood(HH.network,infector)
if (length(infectee.pool)>1){
infectee<-sample(infectee.pool,1) #pick a random individual in the class
}
if(length(infectee.pool)==1){
infectee<-infectee.pool #pick a random individual in the class
}
if(length(infectee.pool)==0){
infectee<-infector #just a trick to have acceptance rate 0 (infector is not susceptible)
}
index.contact.within[infector]<-1
contact.time.within$pr.ctc[infector]<-NA
ctc<-"hh"
}else{
infector<-which(contact.time.between$pr.ctc == events$NextCtc)
hh.members.temp<-which(hh.id==hh.id[infector])
infectee.pool<- setdiff(1:n,hh.members.temp) #individuals not in the same class
infectee<-sample(infectee.pool,1) #pick a random individual not in the class (and not a teacher)
index.contact.between[infector]<-1
contact.time.between$pr.ctc[infector]<-NA
ctc<-"g"
}
}else{
if (length(which(events$NextCtc==contact.time.within$pr.ctc))>0){ #if it is a within contact
infector<-which(contact.time.within$pr.ctc ==events$NextCtc)
infectee.pool<-get.neighborhood(HH.network,infector)
if (length(infectee.pool)>1){
infectee<-sample(infectee.pool,1) #pick a random individual in the class
}
if(length(infectee.pool)==1){
infectee<-infectee.pool #pick a random individual in the class
}
if(length(infectee.pool)==0){
infectee<-infector #just a trick to have acceptance rate 0 (infector is not susceptible)
}
index.contact.within[infector]<-1
contact.time.within$pr.ctc[infector]<-NA
ctc<-"hh"
}else{
infector<-which(contact.time.between$pr.ctc == events$NextCtc)
hh.members.temp<-which(hh.id==hh.id[infector])
infectee.pool<- setdiff(1:n,hh.members.temp) #individuals not in the same class
infectee<-sample(infectee.pool,1) #pick a random individual not in the class (and not a teacher)
index.contact.between[infector]<-1
contact.time.between$pr.ctc[infector]<-NA
ctc<-"g"
}
}
# compute short interaction terms for pathogen.1 (having pathogen 2)
if (status.matrix.2$infected[infectee]==1){
short.inter<-sigma12
}else{
short.inter<-1
}
# compute long interaction terms for pathogen.1 (recovered from pathogen 2)
if (status.matrix.2$infected[infectee]==-1 & lli.2==1){
long.inter<-long.inter.term.2(t=current.time,status.matrix = status.matrix.2,infectee = infectee)
}else{
long.inter<-1
}
#re-infection term
re.inf<-ifelse(status.matrix.1$infected[infectee]==0,1,re.inf.1(t=current.time,status.matrix = status.matrix.1,infectee = infectee))
ifelse(ctc=="g",q<-transmission.parameters$q1g[infector],q<-transmission.parameters$q1h[infector])
acc.rate.1<-InfMeasure(t= current.time- status.matrix.1$time.of.infection[infector] ,pathogen = pathogen.1)*short.inter*long.inter*q*re.inf
if ((ctc=="g" & homequarantine[infectee]==1) | status.matrix.1$infected[infector]!=1){acc.rate.1<-0}
if (acc.rate.1>1){err<-err+1}
if (runif(1)<acc.rate.1){
status.matrix.1$infected[infectee] <- 1
status.matrix.1$time.of.infection[infectee] <- current.time
status.matrix.1$infector[infectee] <- infector
status.matrix.1$Recovery[infectee]<-current.time+infectious.period.length(pathogen=pathogen.1)
if (runif(1)<rho.1){ #if symptomatic
transmission.parameters$q1h[infectee]<-inf.path.1.h #A single q parameter for everyone
transmission.parameters$q1g[infectee]<-inf.path.1.g #A single q parameter for everyone
status.matrix.1$TimeSymptomOnset[infectee]<-current.time+incubation.period(pathogen=pathogen.1)
homequarantine.day.1[infectee]<-status.matrix.1$TimeSymptomOnset[infectee]
status.matrix.1$severity[infectee]<-1
time.events<-rbind(time.events,c(current.time,1.1,infectee))
}else{
transmission.parameters$q1g[infectee]<-inf.path.1.g*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q1h[infectee]<-inf.path.1.h*alpha.as.1 #A single q parameter for everyone
status.matrix.1$severity[infectee]<-2
time.events<-rbind(time.events,c(current.time,1.2,infectee))
}
if (infectives[infectee]==0){
infectives[infectee]<-1
contact.time.within$pr.ctc[infectee]<-ifelse(transmission.parameters$contact_rate_within[infectee]!=0,rexp(1,transmission.parameters$contact_rate_within[infectee])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[infectee]==0){
contact.time.between$pr.ctc[infectee]<-rexp(1,transmission.parameters$contact_rate_between[infectee])+current.time # I generate the next interarrival time for individual i
}
}
}
# compute the long and short interaction terms for pathogen.2
if (status.matrix.1$infected[infectee]==1){
short.inter<-sigma21
}else{
short.inter<-1
}
if (status.matrix.1$infected[infectee]==-1 & lli.1==1){
long.inter<-long.inter.term.1(t=current.time,status.matrix = status.matrix.1,infectee = infectee)
}else{
long.inter<-1
}
#re-infection term
re.inf<-ifelse(status.matrix.2$infected[infectee]==0,1,re.inf.2(t=current.time,status.matrix = status.matrix.2,infectee = infectee))
ifelse(ctc=="g",q<-transmission.parameters$q2g[infector],q<-transmission.parameters$q2h[infector])
acc.rate.2<-InfMeasure(t=(current.time-status.matrix.2$time.of.infection[infector]),pathogen = pathogen.2)*short.inter*long.inter*q*re.inf
if ((ctc=="g" & homequarantine[infectee]==1) | status.matrix.2$infected[infector]!=1){acc.rate.2<-0}
if (acc.rate.2>1){err<-err+1}
if (runif(1)<acc.rate.2){
status.matrix.2$infected[infectee] <- 1
status.matrix.2$time.of.infection[infectee] <- current.time
status.matrix.2$infector[infectee] <- infector
status.matrix.2$Recovery[infectee]<-current.time+infectious.period.length(pathogen=pathogen.2)
if (runif(1)<rho.2){ #if symptomatic
transmission.parameters$q2h[infectee]<-inf.path.2.h #A single q parameter for everyone
transmission.parameters$q2g[infectee]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$TimeSymptomOnset[infectee]<-current.time+incubation.period(pathogen=pathogen.2)
homequarantine.day.2[infectee]<-status.matrix.2$TimeSymptomOnset[infectee]
status.matrix.2$severity[infectee]<-1
time.events<-rbind(time.events,c(current.time,2.1,infectee))
}else{
transmission.parameters$q2g[infectee]<-inf.path.2.g*alpha.as.2 #A single q parameter for everyone
transmission.parameters$q2h[infectee]<-inf.path.2.h*alpha.as.2 #A single q parameter for everyone
status.matrix.2$severity[infectee]<-2
time.events<-rbind(time.events,c(current.time,2.2,infectee))
}
if (infectives[infectee]==0){
infectives[infectee]<-1
contact.time.within$pr.ctc[infectee]<-ifelse(transmission.parameters$contact_rate_within[infectee]!=0,rexp(1,transmission.parameters$contact_rate_within[infectee])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[infectee]==0){
contact.time.between$pr.ctc[infectee]<-rexp(1,transmission.parameters$contact_rate_between[infectee])+current.time # I generate the next interarrival time for individual i
}
}
}
}
if (next.evts=="HomeQuarantine"){
current.time<-events$HomeQuarantine
quarantined.individuals<-which(homequarantine.day.overall==current.time)
for (k in quarantined.individuals){
if (k != n & k!= 2*n) {
temp.ind<- k %% n
}else{
temp.ind<-n
}
if (k>n){
homequarantine.day.2[temp.ind]<-Inf
stop.quarantine[temp.ind]<-status.matrix.2$Recovery[temp.ind]
}else{
homequarantine.day.1[temp.ind]<-Inf
stop.quarantine[temp.ind]<-status.matrix.1$Recovery[temp.ind]
}
if (homequarantine[temp.ind]==1){ #individual is already in quarantine for the other disease
stop.quarantine[temp.ind]<-max(status.matrix.2$Recovery[temp.ind],status.matrix.1$Recovery[temp.ind])
}
homequarantine[temp.ind]<-1
contact.time.between$pr.ctc[temp.ind]<-NA
index.contact.between[temp.ind]<-0
transmission.parameters$contact_rate_within[temp.ind]<-transmission.parameters$contact_rate_within[temp.ind]*contact.reduction
}
}
if (next.evts=="Recovery"){
current.time<-events$Recovery
temp.recovered<-which(recovery.vector.overall==events$Recovery)
for (recovered in temp.recovered){
if (recovered!= n & recovered!=n*2){
if (recovered > n){
recovered<- recovered %% n
status.matrix.2$infected[recovered]<--1
status.matrix.2$Recovery[recovered]<-Inf
time.events<-rbind(time.events,c(current.time,-2,recovered))
if (status.matrix.1$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}else{
status.matrix.1$infected[recovered]<--1
status.matrix.1$Recovery[recovered]<-Inf
time.events<-rbind(time.events,c(current.time,-1,recovered))
if (status.matrix.2$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}
}else{
if (recovered == 2*n){
recovered<- n
status.matrix.2$infected[recovered]<--1
status.matrix.2$Recovery[recovered]<-Inf
time.events<-rbind(time.events,c(current.time,-2,recovered))
if (status.matrix.1$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}else{
status.matrix.1$infected[recovered]<--1
status.matrix.1$Recovery[recovered]<-Inf
time.events<-rbind(time.events,c(current.time,-1,recovered))
if (status.matrix.2$infected[recovered]!=1){
infectives[recovered]<-0
contact.time.between$pr.ctc[recovered]<-NA
contact.time.within$pr.ctc[recovered]<-NA
index.contact.within[recovered]<-0
index.contact.between[recovered]<-0
}else{
if (homequarantine[recovered]==0){
index.contact.between[recovered]<-1
}
}
}
}
if (stop.quarantine[recovered]==current.time){
homequarantine[recovered]<-0
stop.quarantine[recovered]<-Inf
}
}
}
if (next.evts=="NewPathogen"){
current.time<-events$NewPathogen
events$NewPathogen<-Inf
first.cases<-sample(1:n,nSeeds.2)
for (j in first.cases){
first<-j
status.matrix.2$infected[first] <- 1
status.matrix.2$time.of.infection[first] <- current.time
status.matrix.2$Recovery[first]<-current.time+infectious.period.length(pathogen=pathogen.2)
if (runif(1)<rho.2){ #if symptomatic
transmission.parameters$q2h[first]<-inf.path.2.h #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g #A single q parameter for everyone
status.matrix.2$severity[first]<-1
status.matrix.2$TimeSymptomOnset[first]<-current.time+incubation.period(pathogen=pathogen.2)
homequarantine.day.2[first]<-status.matrix.2$TimeSymptomOnset[first]
time.events<-rbind(time.events,c(current.time,2.1,first))
}else{
transmission.parameters$q2h[first]<-inf.path.2.h*alpha.as.1 #A single q parameter for everyone
transmission.parameters$q2g[first]<-inf.path.2.g*alpha.as.1 #A single q parameter for everyone
status.matrix.2$severity[first]<-2
time.events<-rbind(time.events,c(current.time,2.2,first))
}
if (infectives[first]==0){
infectives[first]<-1
contact.time.within$pr.ctc[first]<-ifelse(transmission.parameters$contact_rate_within[first]!=0,rexp(1,transmission.parameters$contact_rate_within[first])+current.time,Inf)       # I generate the next interarrival time for individual i
if (homequarantine[first]==0){
contact.time.between$pr.ctc[first]<-rexp(1,transmission.parameters$contact_rate_between[first])+current.time # I generate the next interarrival time for individual i
}
}
}
}
}
comp.RT<-function(status.matrix,individual,Rt){
infectees<-which(status.matrix$infector==individual)
Rt.temp<-0
if (length(infectees)>0){
for (i1 in 1:length(infectees)){
if (status.matrix$time.of.infection[infectees[i1]]>status.matrix$time.of.infection[individual]){
Rt.temp<-Rt.temp+1
}
}
}
Rt<-rbind(status.matrix$time.of.infection[individual],Rt.temp)
return(Rt)
}
Fs1<-length(which(time.events[,2]==1.1))+length(which(time.events[,2]==1.2))
Fs2<-length(which(time.events[,2]==2.1))+length(which(time.events[,2]==2.2))
